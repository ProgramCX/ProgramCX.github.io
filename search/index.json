[{"content":"题目： 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n示例 1:\n输入: nums = [0,1,0,3,12]\n输出: [1,3,12,0,0]\n示例 2:\n输入: nums = [0]\n输出: [0]\n提示:\n$1 \u0026lt;= nums.length \u0026lt;= 104$ $-231 \u0026lt;= nums[i] \u0026lt;= 231 - 1$ 解法一：二次遍历 思路： 第一个指针用来遍历数组，另外一个指针位于上次与第一个指针指向的数交换的位置。\n大致原理： 一个指针A指向索引为0的位置，另一个指针B从头开始遍历。每当指针B遇到一个非零数，都要把这个数依次从这个数组从头部往后放。从而保证非零数连续的在这个数组前面。然后其它部分填上0。\n主要过程： 指针B 用来遍历数组。 每当遇到非零元素时，指针A 就把它放到当前的位置，并移动到下一个空位置。 最终，指针A会停在数组中的最后一个非零数的位置，而指针B会遍历整个数组。 数组中剩下的部分自动是零，因为非零元素已经被移到了前面。 动画演示（来源于网络）： 解题代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public void moveZeroes(int[] nums) { int insertPos = 0; for (int i = 0; i \u0026lt; nums.length; i++) { if (nums[i] != 0) { nums[insertPos++] = nums[i]; //把非零元素放到当前的前面 } } for (int i = insertPos; i \u0026lt; nums.length; i++) { nums[i] = 0; //其余部分补上0 } } } 复杂度： 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 解法二：交换法（官方给出的解法） 大致原理： 左指针指向上一次交换的位置，右指针遍历数组，当遇到不为零的数，就与左指针指向的数交换位置，总体上会把为零的数不断向右赶。 左指针左边均为非零数； 右指针左边直到左指针处均为零。 因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。\n解题代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public void moveZeroes(int[] nums) { int left = 0; for (int right = 0; right \u0026lt; nums.length; right++) { if (nums[right] != 0) { swap(nums, right, left); left++; } } } public void swap(int[] nums, int left, int right) { int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; } } 复杂度： 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 两者的优缺点分析： 第一种“二次遍历“方法直接赋值操作，节省了开销，但是需要二次遍历，可能会对性能产生影响。 第二种”交换法“无需二次遍历，但是交换操作在某些情况下可能会达到性能瓶颈。 ","date":"2025-02-19T00:00:00Z","image":"https://programcx.github.io/question.png","permalink":"https://programcx.github.io/p/leetcode-%E7%AC%AC283%E9%A2%98-%E7%A7%BB%E5%8A%A8%E9%9B%B6/","title":"LeetCode 第283题 移动零"},{"content":"一、启用Windows Subsystem for Linux 在Windows 10 21H2或更高版本上，启用Windows Subsystem for Linux。\n打开控制面板。 选择“程序和功能”。 选择“启用或关闭Windows功能”。 勾选“适用于Linux的Windows子系统”。 重新启动计算机。 二、安装Ubuntu 22.04 重新启动后，会弹出一个提示更新的窗口，按Enter键等待更新完成。\n1.打开PowerShell，输入以下命令安装Ubuntu 22.04：\n1 2 wsl --set-default-version 2 wsl --install -d Ubuntu 2.等待安装完成，按照提示设置用户名和密码。\n3.此时，默认安装位置为C盘，可以按照以下步骤安装到其它盘：\n1 2 3 wsl --export Ubuntu F:\\wsl\\ubuntu-backup.tar # 导出Ubuntu备份 wsl --unregister Ubuntu # 注销Ubuntu wsl --import Ubuntu F:\\wsl\\ubuntu F:\\wsl\\ubuntu-backup.tar --version 2 # 导入Ubuntu 4.安装完成后，输入以下命令启动Ubuntu：\n1 wsl -d Ubuntu 5.输入以下命令更新软件包：\n1 2 sudo apt update sudo apt upgrade 6.至此，Ubuntu 22.04安装完成。\n记录一下，以后有需要可以参考。\n","date":"2025-02-02T00:00:00Z","image":"https://programcx.github.io/p/windows-%E5%AE%89%E8%A3%85-ubuntu-22.04-%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/Ubuntu_hu3e6f1076ba5decc155d48cb9746e9e0f_24979_120x120_fill_box_smart1_3.png","permalink":"https://programcx.github.io/p/windows-%E5%AE%89%E8%A3%85-ubuntu-22.04-%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/","title":"Windows 安装 Ubuntu 22.04 详细教程"},{"content":"1. \u0026lt;if\u0026gt;元素 当\u0026lt;if\u0026gt;中的test 的值为真时就执行加括号里面的语句，否则就不执行。\n示例如下：\n数据库准备 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 切换数据库 use mall; # 创建数据表 create table customer ( id int(32) primary key auto_increment comment \u0026#39;ID\u0026#39;, name varchar(50) not null comment \u0026#39;Customer Name\u0026#39;, address varchar(50) comment \u0026#39;Customer Address\u0026#39;, phone varchar(20) comment \u0026#39;Customer Phone\u0026#39; ); # 插入数据 insert into customer values(1,\u0026#39;ChengXu\u0026#39;,\u0026#39;AUST\u0026#39;,\u0026#39;666666666666\u0026#39;); insert into customer values(2,\u0026#39;Program\u0026#39;,\u0026#39;AUST\u0026#39;,\u0026#39;888888888888\u0026#39;); insert into customer values(3,\u0026#39;ProgramCX\u0026#39;,\u0026#39;AUST\u0026#39;,\u0026#39;99999999999\u0026#39;); POJO 类准备 在 org.exmaple.pojo 下新建一个 Customer 类，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package org.example.pojo; public class Customer { private int id; private String name; private String address; private String phone; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } @Override public String toString() { return \u0026#34;Customer{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, address=\u0026#39;\u0026#34; + address + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, phone=\u0026#39;\u0026#34; + phone + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } 创建映射文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;org.example.pojo.Customer\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;queryCustomerByNameAndAddress\u0026#34; parameterType=\u0026#34;org.example.pojo.Customer\u0026#34; resultType=\u0026#34;org.example.pojo.Customer\u0026#34;\u0026gt; SELECT * from customer where 1=1 \u0026lt;if test=\u0026#34;name !=null and name !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; and name=#{name} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;phone !=null and phone!=\u0026#39;\u0026#39;\u0026#34;\u0026gt; and phone=#{phone} \u0026lt;/if\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 修改核心配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;!-- 配置文件的根元素 --\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 属性：定义配置外在化 --\u0026gt; \u0026lt;properties resource=\u0026#34;db.properties\u0026#34;/\u0026gt; \u0026lt;!-- 环境：配置mybatis的环境 --\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!-- 环境变量：可以配置多个环境变量，比如使用多数据源时，就需要配置多个环境变量 --\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!-- 事务管理器 --\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;!-- 数据源 --\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${mysql.driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${mysql.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${mysql.username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${mysql.password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;mapper/UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;mapper resource=\u0026#34;mapper/CustomMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; 创建测试类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package Test; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.Test; import java.io.IOException; import java.io.Reader; import org.example.pojo.Customer; public class CustomerTest { @Test public void test() throws IOException { //初始化配置 Reader read = Resources.getResourceAsReader(\u0026#34;mybatis-config.xml\u0026#34;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(read); SqlSession sqlSession = sqlSessionFactory.openSession(); //创建POJO类的实例 Customer customer = new Customer(); customer.setId(1); customer.setAddress(\u0026#34;AUST\u0026#34;); customer.setPhone(\u0026#34;666666666666\u0026#34;); customer = sqlSession.selectOne(\u0026#34;queryCustomerByNameAndAddress\u0026#34;, customer); System.out.println(customer); } } 运行结果 1 2 3 4 \u0026#34;D:\\Program Files\\Java\\jdk-23\\bin\\java.exe\u0026#34; -ea -Didea.test.cyclic.buffer.size=1048576 \u0026#34;-javaagent:D:\\Program Files\\JetBrains\\IntelliJ IDEA 2024.3.1.1\\lib\\idea_rt.jar=50887:D:\\Program Files\\JetBrains\\IntelliJ IDEA 2024.3.1.1\\bin\u0026#34; -javaagent:C:\\Users\\Progr\\AppData\\Local\\JetBrains\\IntelliJIdea2024.3\\captureAgent\\debugger-agent.jar -Dkotlinx.coroutines.debug.enable.creation.stack.trace=false -Ddebugger.agent.enable.coroutines=true -Dkotlinx.coroutines.debug.enable.flows.stack.trace=true -Dkotlinx.coroutines.debug.enable.mutable.state.flows.stack.trace=true -Dfile.encoding=UTF-8 -Dsun.stdout.encoding=UTF-8 -Dsun.stderr.encoding=UTF-8 -classpath \u0026#34;D:\\Program Files\\JetBrains\\IntelliJ IDEA 2024.3.1.1\\lib\\idea_rt.jar;D:\\Program Files\\JetBrains\\IntelliJ IDEA 2024.3.1.1\\plugins\\junit\\lib\\junit5-rt.jar;D:\\Program Files\\JetBrains\\IntelliJ IDEA 2024.3.1.1\\plugins\\junit\\lib\\junit-rt.jar;C:\\Users\\Progr\\IdeaProjects\\untitled\\target\\test-classes;C:\\Users\\Progr\\IdeaProjects\\untitled\\target\\classes;D:\\Program Files\\apache-maven-3.9.9\\repository\\org\\mybatis\\mybatis\\3.5.19\\mybatis-3.5.19.jar;D:\\Program Files\\apache-maven-3.9.9\\repository\\com\\mysql\\mysql-connector-j\\8.0.33\\mysql-connector-j-8.0.33.jar;D:\\Program Files\\apache-maven-3.9.9\\repository\\com\\google\\protobuf\\protobuf-java\\3.21.9\\protobuf-java-3.21.9.jar;D:\\Program Files\\apache-maven-3.9.9\\repository\\junit\\junit\\4.13.2\\junit-4.13.2.jar;D:\\Program Files\\apache-maven-3.9.9\\repository\\org\\hamcrest\\hamcrest-core\\1.3\\hamcrest-core-1.3.jar\u0026#34; com.intellij.rt.junit.JUnitStarter -ideVersion5 -junit4 Test.CustomerTest,test Customer{id=1, name=\u0026#39;ChengXu\u0026#39;, address=\u0026#39;AUST\u0026#39;, phone=\u0026#39;666666666666\u0026#39;} 进程已结束，退出代码为 0 代码分析 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;select id=\u0026#34;queryCustomerByNameAndAddress\u0026#34; parameterType=\u0026#34;org.example.pojo.Customer\u0026#34; resultType=\u0026#34;org.example.pojo.Customer\u0026#34;\u0026gt; SELECT * from customer where 1=1 \u0026lt;if test=\u0026#34;name !=null and name !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; and name=#{name} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;phone !=null and phone!=\u0026#39;\u0026#39;\u0026#34;\u0026gt; and phone=#{phone} \u0026lt;/if\u0026gt; \u0026lt;/select\u0026gt; 这段代码接受一个Customer类作为参数主要对where部分进行了条件判断，当 Customer.name存在时进行name筛选，当Customer.phone存在时进行phone筛选。\n2. \u0026lt;choose\u0026gt;、\u0026lt;when\u0026gt;、\u0026lt;otherwise\u0026gt;元素 使用\u0026lt;if\u0026gt;元素时，可以选择多个元素进行执行；如果需要选择单个元素，用\u0026lt;if\u0026gt;是不合适的，此时应该使用\u0026lt;when\u0026gt;，\u0026lt;when\u0026gt;只能选择单个元素进行执行。有点类似于switch...case...default...语句。\nchoose: 类似于switch。 when: 类似于case。 otherwise: 类似于default。 基本格式:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;!--SQL 语句--\u0026gt; \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;!--SQL 语句--\u0026gt; \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;!--SQL 语句--\u0026gt; \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;!--SQL 语句--\u0026gt; \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; \u0026lt;!--SQL 语句--\u0026gt; \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; 3. \u0026lt;where\u0026gt;和\u0026lt;trim\u0026gt; 3.1 \u0026lt;where\u0026gt; 之前我们在使用\u0026lt;if\u0026gt;元素时，会在where后面加上1=1来确保即使后面条件判断不成立这个 SQL 语句没有语法错误，能够执行\u0026lt;where\u0026gt;可以替代1=1,只要在\u0026lt;if\u0026gt;元素外边包裹一层\u0026lt;where\u0026gt;就可以了，这样既符合逻辑，又清晰明了。\n3.2 \u0026lt;trim\u0026gt; 除了可以使用\u0026lt;where\u0026gt;来实现之外，还可以使用\u0026lt;trim\u0026gt;来实现这个功能，\u0026lt;trim\u0026gt;用来删除多余的关键字。\n下面是\u0026lt;trim\u0026gt;元素的属性：\nprefix：指定给SQL语句增加的前缀； prefixOverrides：指定要给SQL语句中去掉的前缀字符串； suffix：指定要给SQL语句增加的后缀； suffixOverrides：指定要给SQL语句中去掉都后缀字符串。 4. 更新操作 在实际开发中，一般我们只想更新某个对象的某个或多个字段，如果像传统的Hibernate框架，就必须发送所有的字段给持久化对象，这个会导致执行效率非常低。而MyBatis给出了\u0026lt;set\u0026gt;元素，和\u0026lt;if\u0026gt;元素结合可以实现更新需要更新字段的目的。\n格式为：\n1 2 3 4 5 6 7 8 9 update ... \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;...\u0026#34;\u0026gt; ... \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;...\u0026#34;\u0026gt; ... \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; 5. 复杂查询操作 5.1 \u0026lt;foreach\u0026gt;元素的属性 5.1.2 迭代数组 假如有一个数据表，结构如下：\n1 2 3 4 CREATE TABLE users ( id INT PRIMARY KEY, name VARCHAR(50) ); 我们要根据一个id数组来查询多个用户的名字，映射文件可以这样配置：\n1 2 3 4 5 6 7 \u0026lt;select id=\u0026#34;findUsersByIds\u0026#34; parameterType=\u0026#34;int[]\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; SELECT * FROM users WHERE id IN \u0026lt;foreach collection=\u0026#34;array\u0026#34; item=\u0026#34;id\u0026#34; open=\u0026#34;(\u0026#34; separator=\u0026#34;,\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/select\u0026gt; 如果我们这样调用：\n1 2 int[] ids = [1,2,3]; List\u0026lt;User\u0026gt; users = userMapper.findUsersByIds(ids); 会生成下列语句：\n1 SELECT * FROM users WHERE id IN (1, 2, 3); 这个id IN (1, 2, 3)语句其实就是id=1 OR id=2 OR id=3的简写。\n根据所学知识，上述映射文件代码就等价于：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;select id=\u0026#34;findUsersByIds\u0026#34; parameterType=\u0026#34;int[]\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; SELECT * FROM users WHERE \u0026lt;where\u0026gt; \u0026lt;foreach collection=\u0026#34;array\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;OR\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;id != null and id != \u0026#39;\u0026#39;\u0026#34;\u0026gt; id = #{id} \u0026lt;/if\u0026gt; \u0026lt;/foreach\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 5.1.3 迭代List 使用方法类似于Array，只是把传入参数改成List。\n映射文件可以这样配置：\n1 2 3 4 5 6 7 \u0026lt;select id=\u0026#34;findUsersByIds\u0026#34; parameterType=\u0026#34;java.util.Arrays\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; SELECT * FROM users WHERE id IN \u0026lt;foreach collection=\u0026#34;array\u0026#34; item=\u0026#34;id\u0026#34; open=\u0026#34;(\u0026#34; separator=\u0026#34;,\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/select\u0026gt; 调用方法：\n1 2 3 4 List\u0026lt;Integer\u0026gt; ids = new ArrayList\u0026lt;Integer\u0026gt;(); ids.add(1); ids.add(2); List\u0026lt;User\u0026gt; users = userMapper.findUsersByIds(ids); 5.1.3 迭代 Map 通过指定多个限定条件来查询符合条件的用户(AND)，可以使用Map。\n通过id和姓名来查询用户：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;select id=\u0026#34;findUsersByParams\u0026#34; parameterType=\u0026#34;java.util.Map\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; SELECT * FROM users WHERE \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;ids != null and ids.size() \u0026gt; 0\u0026#34;\u0026gt; id IN \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; open=\u0026#34;(\u0026#34; separator=\u0026#34;,\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name != null and name != \u0026#39;\u0026#39;\u0026#34;\u0026gt; AND name = #{name} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 其中，里面的ids就是传入的Map对象的ids键所对应的值（是一个数组），然后通过\u0026lt;foreach\u0026gt;遍历获取每一个id，ids就是传入的Map对象的ids键所对应的值。\n1 2 3 4 5 Map\u0026lt;String, Object\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;ids\u0026#34;, Arrays.asList(1, 2, 3)); // 传入 ids 数组 params.put(\u0026#34;name\u0026#34;, \u0026#34;Alice\u0026#34;); // 传入 name List\u0026lt;User\u0026gt; users = userMapper.findUsersByParams(params); 就会生成这个sql语句：\n1 select * from user where id in (1,2,3) AND name=\u0026#34;Alice\u0026#34;; 实践：学生信息查询系统 利用本章属于知识完成一个学生信息查询系统。该系统要求实现以下三个功能：\n当用户输入的学生姓名不为空时，则只根据学生姓名进行学生信息的查询。 当用户输入的学生姓名为空，而学生专业为空时，则指根据学生专业进行学生信息的查询。 当用户输入的学生姓名和专业都为空，则要求查询出所有学号不为空的学生信息。 第一步：数据库数据准备 登录 MySQL 终端，输入以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 use mall; create table student( name varchar(50), # 学生姓名 major varchar(256), # 专业 id int primary key auto_increment # 学生编号 ); create index idx_student_id on student(id); # 为学生编号创建索引 # 插入数据 insert into student(name, major) values(\u0026#39;zhangsan\u0026#39;, \u0026#39;computer\u0026#39;); insert into student(name, major) values(\u0026#39;lisi\u0026#39;, \u0026#39;mathematics\u0026#39;); insert into student(name, major) values(\u0026#39;wangwu\u0026#39;, \u0026#39;physics\u0026#39;); insert into student(name, major) values(\u0026#39;zhaoliu\u0026#39;, \u0026#39;chemistry\u0026#39;); insert into student(name, major) values(\u0026#39;sunqi\u0026#39;, \u0026#39;biology\u0026#39;); insert into student(name, major) values(\u0026#39;zhouba\u0026#39;, \u0026#39;engineering\u0026#39;); insert into student(name, major) values(\u0026#39;wujiu\u0026#39;, \u0026#39;literature\u0026#39;); insert into student(name, major) values(\u0026#39;zhengshi\u0026#39;, \u0026#39;history\u0026#39;); insert into student(name, major) values(\u0026#39;liuyi\u0026#39;, \u0026#39;philosophy\u0026#39;); insert into student(name, major) values(\u0026#39;qibai\u0026#39;, \u0026#39;art\u0026#39;); insert into student(name, major) values(\u0026#39;bajiu\u0026#39;, \u0026#39;music\u0026#39;); insert into student(name, major) values(\u0026#39;shiyi\u0026#39;, \u0026#39;economics\u0026#39;); insert into student(name, major) values(\u0026#39;shier\u0026#39;, \u0026#39;political science\u0026#39;); insert into student(name, major) values(\u0026#39;shisan\u0026#39;, \u0026#39;sociology\u0026#39;); insert into student(name, major) values(\u0026#39;shisi\u0026#39;, \u0026#39;psychology\u0026#39;); insert into student(name, major) values(\u0026#39;shiwu\u0026#39;, \u0026#39;law\u0026#39;); insert into student(name, major) values(\u0026#39;shiliu\u0026#39;, \u0026#39;medicine\u0026#39;); insert into student(name, major) values(\u0026#39;shiqi\u0026#39;, \u0026#39;nursing\u0026#39;); insert into student(name, major) values(\u0026#39;shiba\u0026#39;, \u0026#39;education\u0026#39;); insert into student(name, major) values(\u0026#39;shijiu\u0026#39;, \u0026#39;business\u0026#39;); insert into student(name, major) values(\u0026#39;ershi\u0026#39;, \u0026#39;architecture\u0026#39;); 第二步：创建 POJO 类 在org.example.pojo包下新建一个Student.java文件，创建 POJO 类 Student\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package Test; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.example.pojo.Student; import org.junit.Test; import java.io.IOException; import java.io.Reader; import java.util.List; public class StudentTest { private static SqlSession sqlSession; @Test public void test1() throws IOException { Student student = new Student(); student.setName(\u0026#34;zhangsan\u0026#34;); SqlSession session=getSession(); List\u0026lt;Student\u0026gt; list=session.selectList(\u0026#34;findStudent\u0026#34;,student); for(Student s:list){ System.out.println(s); } } @Test public void test2() throws IOException { Student student = new Student(); student.setMajor(\u0026#34;economics\u0026#34;); SqlSession session=getSession(); List\u0026lt;Student\u0026gt; list=session.selectList(\u0026#34;findStudent\u0026#34;,student); for(Student s:list){ System.out.println(s); } } @Test public void test3() throws IOException { Student student = new Student(); sqlSession=getSession(); List\u0026lt;Student\u0026gt; list=sqlSession.selectList(\u0026#34;findStudent\u0026#34;,student); for(Student s:list){ System.out.println(s); } } public static SqlSession getSession() throws IOException { if(sqlSession == null){ Reader reader = Resources.getResourceAsReader(\u0026#34;mybatis-config.xml\u0026#34;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); sqlSession = sqlSessionFactory.openSession(); } return sqlSession; } } 第三步：Mapper 映射文件配置 创建 StudentMapper，创建映射关系和查询条件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;org.example.pojo.Student\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;findStudent\u0026#34; parameterType=\u0026#34;org.example.pojo.Student\u0026#34; resultType=\u0026#34;org.example.pojo.Student\u0026#34;\u0026gt; select * from student \u0026lt;where\u0026gt; \u0026lt;!--当用户输入的学生姓名不为空时，则只根据学生姓名进行学生信息的查询。--\u0026gt; \u0026lt;if test=\u0026#34;name!=null and name!=\u0026#39;\u0026#39;\u0026#34;\u0026gt; name=#{name} \u0026lt;/if\u0026gt; \u0026lt;!--当用户输入的学生姓名为空，而学生专业为空时，则指根据学生专业进行学生信息的查询。--\u0026gt; \u0026lt;if test=\u0026#34;(name==null or name==\u0026#39;\u0026#39;) and (major!=\u0026#39;\u0026#39; and major!=null)\u0026#34;\u0026gt; major=#{major} \u0026lt;/if\u0026gt; \u0026lt;!--当用户输入的学生姓名和专业都为空，则要求查询出所有学号不为空的学生信息。--\u0026gt; \u0026lt;if test=\u0026#34;(name==null or name==\u0026#39;\u0026#39;) and (major==\u0026#39;\u0026#39; or major==null)\u0026#34;\u0026gt; id!=0 \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 第四步：配置 MyBatis 配置文件 在mybatis-config.xml 里，把 StudentMapper.xml 文件包含进去：\n1 \u0026lt;mapper resource=\u0026#34;mapper/StudentMapper.xml\u0026#34;/\u0026gt; 第五步：创建测试类 在 test/java/Test 目录下创建 StudentTest.java 文件，添加以下测试方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 package Test; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.example.pojo.Student; import org.junit.Test; import java.io.IOException; import java.io.Reader; import java.util.List; public class StudentTest { private static SqlSession sqlSession; @Test //当用户输入的学生姓名不为空时，则只根据学生姓名进行学生信息的查询。 public void test1() throws IOException { Student student = new Student(); student.setName(\u0026#34;zhangsan\u0026#34;); SqlSession session=getSession(); List\u0026lt;Student\u0026gt; list=session.selectList(\u0026#34;findStudent\u0026#34;,student); for(Student s:list){ System.out.println(s); } } @Test //当用户输入的学生姓名为空，而学生专业为空时，则指根据学生专业进行学生信息的查询。 public void test2() throws IOException { Student student = new Student(); student.setMajor(\u0026#34;economics\u0026#34;); SqlSession session=getSession(); List\u0026lt;Student\u0026gt; list=session.selectList(\u0026#34;findStudent\u0026#34;,student); for(Student s:list){ System.out.println(s); } } @Test //当用户输入的学生姓名和专业都为空，则要求查询出所有学号不为空的学生信息。 public void test3() throws IOException { Student student = new Student(); sqlSession=getSession(); List\u0026lt;Student\u0026gt; list=sqlSession.selectList(\u0026#34;findStudent\u0026#34;,student); for(Student s:list){ System.out.println(s); } } public static SqlSession getSession() throws IOException { if(sqlSession == null){ Reader reader = Resources.getResourceAsReader(\u0026#34;mybatis-config.xml\u0026#34;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); sqlSession = sqlSessionFactory.openSession(); } return sqlSession; } } 第五步：查看运行结果😆 成功了，这一章学习圆满结束！🎆🎆\n输出结果如下：\ntest1：\n1 Student [name=zhangsan, major=computer, id=1] test2：\n1 Student [name=shiyi, major=economics, id=12] test3：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Student [name=zhangsan, major=computer, id=1] Student [name=lisi, major=mathematics, id=2] Student [name=wangwu, major=physics, id=3] Student [name=zhaoliu, major=chemistry, id=4] Student [name=sunqi, major=biology, id=5] Student [name=zhouba, major=engineering, id=6] Student [name=wujiu, major=literature, id=7] Student [name=zhengshi, major=history, id=8] Student [name=liuyi, major=philosophy, id=9] Student [name=qibai, major=art, id=10] Student [name=bajiu, major=music, id=11] Student [name=shiyi, major=economics, id=12] Student [name=shier, major=political science, id=13] Student [name=shisan, major=sociology, id=14] Student [name=shisi, major=psychology, id=15] Student [name=shiwu, major=law, id=16] Student [name=shiliu, major=medicine, id=17] Student [name=shiqi, major=nursing, id=18] Student [name=shiba, major=education, id=19] Student [name=shijiu, major=business, id=20] Student [name=ershi, major=architecture, id=21] ","date":"2025-01-22T00:00:00Z","image":"https://programcx.github.io/p/mybatis-%E5%8A%A8%E6%80%81-sql-%E8%AF%AD%E5%8F%A5/MyBatis_huf530186ff050aabde73a47f8290c5d55_111513_120x120_fill_box_smart1_3.png","permalink":"https://programcx.github.io/p/mybatis-%E5%8A%A8%E6%80%81-sql-%E8%AF%AD%E5%8F%A5/","title":"MyBatis 动态 SQL 语句"},{"content":"MyBatis 中核心对象 1. SqlSession SqlSession 中提供了不同的查询方法。其中可以查询单个，也可以查询符合查询条件的集合。不但可以进行查询操作，也可以进行增删改的功能。下面介绍几个常用的方法：\n\u0026lt;T\u0026gt; T selectOne(String statement, Object parameter) : parameter 是语句所需要的参数，用来将参数传递给 SQL 语句。该方法会返回一个xml映射配置中指定的类型。 \u0026lt;E\u0026gt; List\u0026lt;E\u0026gt; selectList(String statement, Object parameter) :查询泛型对象的集合。 int insert(String statement, Object parameter) ：插入方法，参数statement 是\u0026lt;insert\u0026gt; 的id，parameter 是插入语句所需要的参数，也就是后面要学到的parameterType int update(String statement, Object parameter),int delete(String statement, Object parameter) 用法类似。 void commit()：提交事务。 void rollback()：回滚事务。 void close()：关闭SqlSession对象。 2. MyBatis 核心配置文件元素 2.2 \u0026lt;properties\u0026gt;元素 用来存放数据库连接驱动类型、sql地址、用户名和密码。然后在mybatis-config.xml里面引入、使用。\n2.3 \u0026lt;typeAlias\u0026gt;元素 给全限定名起一个别名(Alias)。\n在mybatis-config.xml文件里面加上：\n1 2 3 \u0026lt;typeAliases\u0026gt; \u0026lt;typeAlias alias=\u0026#34;User\u0026#34; type=\u0026#34;org.example.pojo.User\u0026#34; /\u0026gt; \u0026lt;/typeAliases\u0026gt; 2.4 \u0026lt;environments\u0026gt;元素 可以给开发环境、生产环境进行不同的配置。\nUNPOOLED：无连接池类型。每次请求会打开和关闭数据库。适用于对性能要求不高的简单应用程序。 POOLED：连接池类型。 2.6 \u0026lt;mappers\u0026gt;元素 用来引入映射文件。基本结构：\n1 2 3 \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;mapper/UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 2.7 \u0026lt;select\u0026gt;元素 该标签可以实现查询操作，可以将查询结果映射为POJO对象，并且返回。\n简单的查询例子：\n1 2 3 4 5 6 \u0026lt;select id=\u0026#34;findUserById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;cn.programcx.POJO.User\u0026#34; \u0026gt; SELECT * FROM user WHERE id = #{id} \u0026lt;/select\u0026gt; 这个语句接受一个int类型的参数，返回一个cn.programcx.POJO包中的对象。\n参数：\n属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterType 将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。 resultType 期望从这条语句中返回结果的类全限定名或别名。注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。 resultMap 期望从这条语句中返回结果的类全限定名或别名。注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。 flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。 useCache 将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 fetchSize 这是一个给驱动的建议值，尝试让驱动程序每次批量返回的结果行数等于这个设置值。默认值为未设置（unset）（依赖驱动）。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 resultSetType FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset）中的一个，默认值为 unset（依赖数据库驱动）。 databaseId 如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。 resultOrdered 这个设置仅针对嵌套结果 select 语句：如果为 true，将会假设包含了嵌套结果集或是分组，当返回一个主结果行时，就不会产生对前面结果集的引用。默认值：false。 resultSets 这个设置仅适用于多结果集的情况。它将列出语句执行后返回的结果集并赋予每个结果集一个名称，多个名称之间以逗号分隔。 注意：如果映射的POJO对象和指定查询的数据表中名称不一致，不能使用resultType，否则无法进行映射，会抛出异常；如果名称不一致，应使用resultMap（后面介绍）。\n2.8 \u0026lt;insert\u0026gt;元素 insert标签用来指定插入记录的操作和属性。\n1 2 3 4 5 6 \u0026lt;insert id=\u0026#34;insertUser\u0026#34; parameterType=\u0026#34;cn.programcx.POJO\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34;\u0026gt; INSERT INTO user(name,sex,email,phone,address,password) values (#{name},#{sex},#{email},#{phone},#{address},#{password}) \u0026lt;/insert\u0026gt; 其中，#{name}表示映射的POJO对象的成员变量·name。\n属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterType 将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。 parameterMap 用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。 flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：（对 insert、update 和 delete 语句）true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（unset）。如果生成列不止一个，可以用逗号分隔多个属性名称。 keyColumn （仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。 databaseId 如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。 2.9 \u0026lt;update\u0026gt;元素 用来更新记录。\n1 2 3 4 5 6 \u0026lt;update id=\u0026#34;updateUser\u0026#34; parameterType=\u0026#34;cn.programcx.POJO.user\u0026#34; \u0026gt; UPDATE user SET name = #{name},email = #{email},password = #{password} WHERE userId = #{userId} \u0026lt;/update\u0026gt; 属性和上面的insert一样。\n2.10 \u0026lt;delete\u0026gt;元素 用来删除记录\n1 2 3 4 5 6 \u0026lt;delete id=\u0026#34;deleteUser\u0026#34; \u0026gt;\u0026lt;/delete\u0026gt; DELETE FROM user WHERE id=#{id} \u0026lt;/delete\u0026gt; 2.11 \u0026lt;selectKey\u0026gt;元素 用来自定义生成一个属性的值。\n例如，插入用户为用户随机生成id并插入数据表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;insert id=\u0026#34;insertUser\u0026#34; parameterType=\u0026#34;cn.programcx.POJO.user\u0026#34;\u0026gt; \u0026lt;selectKey keyProperty=\u0026#34;userId\u0026#34; resultType=\u0026#34;int\u0026#34; order=\u0026#34;BEFORE\u0026#34;\u0026gt; select CAST(RANDOM()*1000000 as INTEGER) a from SYSIBM.SYSDUMMY1 \u0026lt;/selectKey\u0026gt; INSERT INTO user(userId,name,sex,email,phone,address,password) values (#{userId},#{name},#{sex},#{email},#{phone},#{address},#{password}) \u0026lt;/insert\u0026gt; 2.11 \u0026lt;resultMap\u0026gt;元素 \u0026lt;resultMap\u0026gt;的作用是自定义映射规则。如果数据表字段名称和POJO类中所需要映射到属性的名称不一致，就不能仅仅指定parameterType或resultType来实现映射，必须要通过自定义映射来实现。 其基本格式是：\n1 2 3 4 \u0026lt;resultMap type=\u0026#34;[完整类名]\u0026#34; id=\u0026#34;[标识这个自定义映射的字符串]\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;[POJO类中的属性名称]\u0026#34; column=\u0026#34;[字段名称]\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;[POJO类中的属性名称]\u0026#34; column=\u0026#34;[字段名称]\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; ","date":"2025-01-16T00:00:00Z","image":"https://programcx.github.io/p/mybatis-%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/MyBatis_huf530186ff050aabde73a47f8290c5d55_111513_120x120_fill_box_smart1_3.png","permalink":"https://programcx.github.io/p/mybatis-%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/","title":"MyBatis 常用配置"},{"content":"一、环境搭建 依赖引入 在pom.xml文件中添加以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;dependencies\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.19\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/com.mysql/mysql-connector-j --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;9.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/junit/junit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.13.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;\u0026lt;/dependencies\u0026gt; 创建数据库连接信息配置文件 在src/main/resources 目录下创建数据库连接的配置文件，命名为db.properties，用来配置数据库连接时的参数。\n1 2 3 4 mysql.driver = com.mysql.cj.jdbc.Driver mysql.url = jdbc:mysql://localhost:3306/mall?serverTimezone=UTC\u0026amp;\\characterEncoding=utf8\u0026amp;useUnicode=true\u0026amp;useSSL=false mysql.username = root mysql.password = mysql 创建 Mybatis 的核心配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;!-- 配置文件的根元素 --\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 属性：定义配置外在化 --\u0026gt; \u0026lt;properties resource=\u0026#34;db.properties\u0026#34;/\u0026gt; \u0026lt;!-- 环境：配置mybatis的环境 --\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!-- 环境变量：可以配置多个环境变量，比如使用多数据源时，就需要配置多个环境变量 --\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!-- 事务管理器 --\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;!-- 数据源 --\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${mysql.driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${mysql.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${mysql.username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${mysql.password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;/configuration\u0026gt; 二、MyBatis 入门程序 第一步：创建 POJO 实体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package org.example.pojo; public class User { private int userID; private String userName; private String sex; public int getUserID() { return userID; } public void setUserID(int userID) { this.userID = userID; } public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } } POJO 实体用来从数据库映射的值。\n第二步：创建映射文件 UserMapper.xml 文件命名 文件命名通常使用POJO 实体类名+Mapper 命名。例如User 实体类映射文件名为 UserMapper.xml 。\n1 2 3 4 5 6 7 8 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;org.example.pojo.User\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;findUserById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;org.example.pojo.User\u0026#34;\u0026gt; select * from user where userID = # {id} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 第三步：在 mybatis-config.xml 配置文件里面添加映射 1 2 3 \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;mapper/UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 此代码在\u0026lt;configuration\u0026gt;\u0026lt;configuration/\u0026gt; 里面直接添加。\n第四步：编写测试类 在 test/java/Test 下创建 UserTest.java 文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package Test; import org.example.pojo.User; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.Test; import java.io.IOException; import java.io.Reader; public class UserTest { @Test public void test() throws IOException { //第一步：将 mybatis-config.xml 文件里面的内容加载到 reader 对象中 Reader reader = Resources.getResourceAsReader(\u0026#34;mybatis-config.xml\u0026#34;); //第二步：初始化MyBatis数据库，创建 SqlSessionFactory 类的实例 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); //第三步：创建SqlSession会话实例 SqlSession sqlSession = sqlSessionFactory.openSession(); //获取查询到的结果映射到的对象 User user = sqlSession.selectOne(\u0026#34;findUserById\u0026#34;, 1); System.out.println(user.getUserName()); sqlSession.close(); } } 在上述代码中，先通过Resource的getResourceReader()方法来将 MyBatis 配置文件加载到 reader 对象中，接着将read传入 SqlSessionFactoryBuilder().build() 工厂方法来构建SqlSessionFactory 类的对象。之后这个对象调用openSession方法来获取一个SqlSession会话。然后调用selectOne()来获取查询到的结果映射到的对象。最后就可以用Get方法来获取想得到的数据了。\n运行测试，得到结果：\n1 ChengXu ","date":"2025-01-15T00:00:00Z","image":"https://programcx.github.io/p/mybatis-%E5%85%A5%E9%97%A8/MyBatis_huf530186ff050aabde73a47f8290c5d55_111513_120x120_fill_box_smart1_3.png","permalink":"https://programcx.github.io/p/mybatis-%E5%85%A5%E9%97%A8/","title":"MyBatis 入门"},{"content":"Java 实现文件下载 使用HttpClient下载 阻塞方式下载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import java.io.IOException; import java.net.URI; import java.net.http.HttpRequest; import java.net.http.HttpResponse; import java.net.http.HttpClient; import java.nio.file.Paths; import java.nio.file.Path; public class Main { public static void main(String[] args) { downloadAFile(\u0026#34;https://pc-package.wpscdn.cn/wps/download/W.P.S.20.2735.exe\u0026#34;, \u0026#34;W.P.S.20.2735.exe\u0026#34;); } public static void downloadAFile(String url, String fileName) { HttpClient client = HttpClient.newHttpClient(); //创建一个HttpRequest请求 HttpRequest request = HttpRequest.newBuilder(URI.create(url)).build(); Path filePath = Paths.get(fileName); try { //发送Http请求 HttpResponse\u0026lt;Path\u0026gt; response = client.send(request, HttpResponse.BodyHandlers.ofFile(filePath)); //判断是否成功下载 if (response.statusCode() == 200) { System.out.printf(\u0026#34;文件%s已经成功保存!\u0026#34;, fileName); } } catch (IOException | InterruptedException e) { throw new RuntimeException(e); } } } 在上述代码中，实现了一个名为downloadAFile()函数。使用 HttpClient.send() 方法发送Http请求并将响应体写入文件，并获得HttpResponse\u0026lt;Path\u0026gt;类型的response对象，使用该对象获得请求的状态码statusCode。\n异步方式下载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import java.io.IOException; import java.net.URI; import java.net.http.HttpRequest; import java.net.http.HttpResponse; import java.net.http.HttpClient; import java.nio.file.Paths; import java.nio.file.Path; import java.util.Scanner; public class Main { public static void main(String[] args) { downloadAFile(\u0026#34;https://pc-package.wpscdn.cn/wps/download/W.P.S.20.2735.exe\u0026#34;, \u0026#34;W.P.S.20.2735.exe\u0026#34;); System.out.println(\u0026#34;下载已经开始，按回车键结束...\u0026#34;); Scanner scanner = new Scanner(System.in); scanner.nextLine(); } public static void downloadAFile(String url, String fileName) { HttpClient client = HttpClient.newHttpClient(); //创建一个HttpRequest请求 HttpRequest request = HttpRequest.newBuilder(URI.create(url)).build(); Path filePath = Paths.get(fileName); //异步下载 client.sendAsync(request, HttpResponse.BodyHandlers.ofFile(filePath)).thenAccept(Main::downloadCallBack).exceptionally(e -\u0026gt; { System.out.println(\u0026#34;下载失败！\u0026#34; + e.getMessage()); return null; }); } private static void downloadCallBack(HttpResponse\u0026lt;Path\u0026gt; pathHttpResponse) { if (pathHttpResponse.statusCode() == 200) { System.out.println(\u0026#34;下载成功！文件已经保存至：\u0026#34; + pathHttpResponse.body()); } else { System.out.printf(\u0026#34;下载失败！状态码为%d。\\n\u0026#34;, pathHttpResponse.statusCode()); } } } 这里使用client.sendAsync()异步下载文件，thenAccept()来指定下载完成时的回调函数，exceptionally()来处理异常。注意，由于这里是异步下载的，不能使用try{}catch{}来处理异常，异常不能被捕获。\n使用OKHttp下载 导入OkHttp依赖 在pom.xml的\u0026lt;dependencies\u0026gt;\u0026lt;/dependencies\u0026gt;中添加以下代码：\n1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/com.squareup.okhttp3/okhttp --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.squareup.okhttp3\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;okhttp\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.14.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; OKHttp获取文本文件 Download.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package org.example; import okhttp3.*; import java.io.IOException; public class Download{ public final OkHttpClient client = new OkHttpClient(); public void run() throws IOException { Request request = new Request.Builder().url(\u0026#34;http://www.baidu.com\u0026#34;).build(); try(Response response = client.newCall(request).execute()){ if (response.body() != null) { System.out.println(response.body().string()); } }catch (Exception e){ System.out.println(e.getMessage()); } } } Main.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package org.example; import java.io.IOException; public class Main { public static void main(String[] args) { Download download = new Download(); try{ download.run(); } catch (IOException e) { throw new RuntimeException(e); } } } OKHttp异步请求 Download.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package org.example; import okhttp3.*; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.util.Objects; public class Download { private final String url; private final String fileName; private final String filePath; private final OkHttpClient client = new OkHttpClient(); public Download(String url, String fileName, String filePath) { this.url = url; this.fileName = fileName; this.filePath = filePath; } public void run() { Request request = new Request.Builder().url(url).build(); Call call = client.newCall(request); call.enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { e.printStackTrace(); } @Override //响应时的回调函数 public void onResponse(Call call, Response response) throws IOException { if (!response.isSuccessful()) { throw new IOException(\u0026#34;Unexpected code \u0026#34; + response); } try (InputStream inputStream = Objects.requireNonNull(response.body()).byteStream(); //从响应体获取字节流 FileOutputStream outputStream = new FileOutputStream(new File(filePath, fileName))) { //创建文件输出流 byte[] buffer = new byte[2048]; //创建缓存区，大小为2048KB int len; //用于还剩下多少字节没有被读取 while ((len = inputStream.read(buffer)) != -1) { //还没有被读取完 outputStream.write(buffer, 0, len); //将缓冲区数据写入文件 } System.out.printf(\u0026#34;文件%s已下载至%s%n\u0026#34;, fileName, filePath); } catch (IOException e) { e.printStackTrace(); } } }); } } Main.java\n1 2 3 4 5 6 7 8 9 10 11 package org.example; public class Main { public static void main(String[] args) { String url = \u0026#34;https://down-tencent.huorong.cn/sysdiag-all-x64-6.0.4.0-2024.11.16.1.exe\u0026#34;; String filename = \u0026#34;sysdiag-all-x64-6.0.4.0-2024.11.16.1.exe\u0026#34;; Download download = new Download(url, filename, \u0026#34;D:/\u0026#34;); download.run(); } } 上述代码中，使用Request.Builder().url(url).build()创建一个Request对象，使用Call类的call对象发起Http Get请求，使用enqueue()方法处理响应和错误。 在处理响应时，首先将response.body()响应体通过byteStream()方法转化为字节流，然后于FileInputStream一起使用写入文件。\nOKHttp同步请求 无需使用call.enqueue()方法，最后使用断言assertThat(response.code(), equalTo(200));判断状态码是否等于200即可。\n自定义请求头 1 Request request = new Request.Builder().url(url).addHeader(\u0026#34;Content-Length\u0026#34;,\u0026#34;application/x-msdownload\u0026#34;).build(); 允许重定向 1 private final OkHttpClient client = new OkHttpClient().newBuilder().followRedirects(true).build(); 超时设置 1 private final OkHttpClient client = new OkHttpClient().newBuilder().readTimeout(3, TimeUnit.SECONDS).build(); 取消请求 可以使用Call.cancel()终止请求。\n","date":"2024-11-16T00:00:00Z","image":"https://programcx.github.io/p/java-%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/java_hu2582121eb752963b1ceb7fad85fc990d_36519_120x120_fill_q75_box_smart1.jpg","permalink":"https://programcx.github.io/p/java-%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/","title":"Java 实现文件下载"},{"content":"Vue 3 报错Uncaught TypeError:xxx.component is not a function 记录学习Vue 3过程中踩的坑\n一、错误代码 有以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 const vueWatcher = { methods: { click(index) { if (index == 0) { alert(\u0026#34;外层\u0026#34;); } else if (index == 1) { alert(\u0026#34;中层\u0026#34;); } else if (index == 2) { alert(\u0026#34;内层\u0026#34;); } }, KeyDownCtrl() { alert(\u0026#34;Ctrl Pressed\u0026#34;); } } } const app = Vue.createApp(vueWatcher).mount(\u0026#34;#vue-watcher\u0026#34;); const alertComponent = { data() { return { msg: \u0026#34;警告\u0026#34;, } }, methods: { click() { alert(this.msg); } }, template: \u0026#39;\u0026lt;div\u0026gt;\u0026lt;button @click=\u0026#34;click\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt;\u0026#39; } app.component(\u0026#34;alert-component\u0026#34;, alertComponent); 我们是想要给 app对象添加一个标准的Vue组件alert-component，但是浏览器报错Uncaught TypeError:app.component is not a function。\n二、分析原因 其实这是一个添加子组件顺序的问题。上述错误代码中，先创建一个名为app的Vue对象，接着挂载到vue-watcher上，最后添加子组件alert-componet。 这种顺序是错误的，正确的顺序应该是：\n创建一个名为app的Vue对象； 1 const app = Vue.createApp(vueWatcher); 添加子组件alert-componet； 1 app.component(\u0026#34;alert-component\u0026#34;, alertComponent); 挂载到vue-watcher上。 1 app.mount(\u0026#34;#vue-watcher\u0026#34;); 三、正确代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const vueWatcher = { methods: { click(index) { if (index == 0) { alert(\u0026#34;外层\u0026#34;); } else if (index == 1) { alert(\u0026#34;中层\u0026#34;); } else if (index == 2) { alert(\u0026#34;内层\u0026#34;); } }, KeyDownCtrl() { alert(\u0026#34;Ctrl Pressed\u0026#34;); } } } const app = Vue.createApp(vueWatcher); const alertComponent = { data() { return { msg: \u0026#34;警告\u0026#34;, } }, methods: { click() { alert(this.msg); } }, template: \u0026#39;\u0026lt;div\u0026gt;\u0026lt;button @click=\u0026#34;click\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt;\u0026#39; } app.component(\u0026#34;my\u0026#34;, alertComponent); app.mount(\u0026#34;#vue-watcher\u0026#34;); 欢迎指正错误！\n","date":"2024-10-15T00:00:00Z","image":"https://programcx.github.io/p/uncaught-typeerrorxxx.component-is-not-a-function/vue.svg","permalink":"https://programcx.github.io/p/uncaught-typeerrorxxx.component-is-not-a-function/","title":"Uncaught TypeError:xxx.component is not a function"},{"content":"Qt 5.15 connect() 函数的一个大坑 有以下代码：\n1 2 3 4 5 connect(ui-\u0026gt;styleComboBox, \u0026amp;QComboBox::currentIndexChanged, this, [this](int index) { //TODO: change theme spdlog::info(\u0026#34;User change default theme to {}\u0026#34;, index); AppConfig::instance().setBasic(\u0026#34;style\u0026#34;, index); }); 以上代码将ui-\u0026gt;styleComboBox的QComboBox::currentTextChanged信号连接至lambda表达式里的匿名函数。看似没有什么问题，但是在Qt 5.15上报错：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /Users/runner/work/FlowD/FlowD/src/SettingsBasicWidget.cpp:21:5: error: no matching member function for call to \u0026#39;connect\u0026#39; connect(ui-\u0026gt;styleComboBox, \u0026amp;QComboBox::currentIndexChanged, this, [this](int index) { ^~~~~~~ /Users/runner/work/FlowD/Qt/5.15.2/clang_64/lib/QtCore.framework/Headers/qobject.h:222:36: note: candidate function not viable: no overload of \u0026#39;currentIndexChanged\u0026#39; matching \u0026#39;const char *\u0026#39; for 2nd argument static QMetaObject::Connection connect(const QObject *sender, const char *signal, ^ /Users/runner/work/FlowD/Qt/5.15.2/clang_64/lib/QtCore.framework/Headers/qobject.h:225:36: note: candidate function not viable: no overload of \u0026#39;currentIndexChanged\u0026#39; matching \u0026#39;const QMetaMethod\u0026#39; for 2nd argument static QMetaObject::Connection connect(const QObject *sender, const QMetaMethod \u0026amp;signal, ^ /Users/runner/work/FlowD/Qt/5.15.2/clang_64/lib/QtCore.framework/Headers/qobject.h:481:41: note: candidate function not viable: no overload of \u0026#39;currentIndexChanged\u0026#39; matching \u0026#39;const char *\u0026#39; for 2nd argument inline QMetaObject::Connection QObject::connect(const QObject *asender, const char *asignal, ^ /Users/runner/work/FlowD/Qt/5.15.2/clang_64/lib/QtCore.framework/Headers/qobject.h:242:43: note: candidate template ignored: couldn\u0026#39;t infer template argument \u0026#39;Func1\u0026#39; static inline QMetaObject::Connection connect(const typename QtPrivate::FunctionPointer\u0026lt;Func1\u0026gt;::Object *sender, Func1 signal, ^ /Users/runner/work/FlowD/Qt/5.15.2/clang_64/lib/QtCore.framework/Headers/qobject.h:283:13: note: candidate template ignored: couldn\u0026#39;t infer template argument \u0026#39;Func1\u0026#39; connect(const typename QtPrivate::FunctionPointer\u0026lt;Func1\u0026gt;::Object *sender, Func1 signal, const QObject *context, Func2 slot, ^ /Users/runner/work/FlowD/Qt/5.15.2/clang_64/lib/QtCore.framework/Headers/qobject.h:322:13: note: candidate template ignored: couldn\u0026#39;t infer template argument \u0026#39;Func1\u0026#39; connect(const typename QtPrivate::FunctionPointer\u0026lt;Func1\u0026gt;::Object *sender, Func1 signal, const QObject *context, Func2 slot, ^ /Users/runner/work/FlowD/Qt/5.15.2/clang_64/lib/QtCore.framework/Headers/qobject.h:274:13: note: candidate function template not viable: requires 3 arguments, but 4 were provided connect(const typename QtPrivate::FunctionPointer\u0026lt;Func1\u0026gt;::Object *sender, Func1 signal, Func2 slot) ^ /Users/runner/work/FlowD/Qt/5.15.2/clang_64/lib/QtCore.framework/Headers/qobject.h:314:13: note: candidate function template not viable: requires 3 arguments, but 4 were provided connect(const typename QtPrivate::FunctionPointer\u0026lt;Func1\u0026gt;::Object *sender, Func1 signal, Func2 slot) ^ 1 error generated. 为什么会出现这种情况呢？ 因为QComboBox 有两个重载的信号，原型分别是void\tcurrentTextChanged(const QString \u0026amp;text)和void\tcurrentIndexChanged(int index)，上面的代码我们明显是想要连接void\tcurrentIndexChanged(int index)这个信号，但是编译器当成了void\tcurrentTextChanged(const QString \u0026amp;text)这个信号，所以会报出参数不匹配的错误:matching member function for call to 'connect' connect(ui-\u0026gt;styleComboBox, \u0026amp;QComboBox::currentIndexChanged, this, [this](int index) 。 上面的代码在Qt 6上不会报错。\n我们该如何解决呢？只需使用预定义宏，将比Qt 6.0.0版本低的部分的代码改成QOverload\u0026lt;int\u0026gt;::of(\u0026amp;QComboBox::currentIndexChanged)即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #if QT_VERSION \u0026lt;= QT_VERSION_CHECK(6, 0, 0) connect(ui-\u0026gt;styleComboBox, QOverload\u0026lt;int\u0026gt;::of(\u0026amp;QComboBox::currentIndexChanged), this, [this](int index) { //TODO: change theme spdlog::info(\u0026#34;User change default theme to {}\u0026#34;, index); AppConfig::instance().setBasic(\u0026#34;style\u0026#34;, index); }); #else connect(ui-\u0026gt;styleComboBox, \u0026amp;QComboBox::currentIndexChanged, this, [this](int index) { //TODO: change theme spdlog::info(\u0026#34;User change default theme to {}\u0026#34;, index); AppConfig::instance().setBasic(\u0026#34;style\u0026#34;, index); }); #endif ","date":"2024-09-16T00:00:00Z","image":"https://programcx.github.io/p/qt-5.15-connect-%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A4%A7%E5%9D%91/qt_hu6cd4f64cbe970e806893d3bd1f4a2f5a_17484_120x120_fill_q75_h2_box_smart1_2.webp","permalink":"https://programcx.github.io/p/qt-5.15-connect-%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A4%A7%E5%9D%91/","title":"Qt 5.15 connect() 函数的一个大坑"},{"content":"Java中super关键字的理解 访问超类的成员函数和变量 举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Main { public static void main(String[] args) { Manager manager = new Manager(); manager.setBonus(8000); System.out.println(manager.getSalary()); } } class Employee{ private int salary = 6000; public void setSalary(int salary){ this.salary=salary; } public int getSalary(){ return salary; } } class Manager extends Employee{ private int bonus = 0; public void setBonus(int bonus){ this.bonus=bonus; } public int getBonus(){ return bonus; } //覆盖超类的函数 @Override public int getSalary(){ return bonus + this.salary; } } 这段代码声明了超类Employee，以及继承了这个超类的Manager类。定义了Manager类的manager对象，manager的奖金设置为8000元。最后打印出manager的总薪水。 但是，这段代码有一个很严重的错误。由于在超类Employee中，salary为private类型的，所以manager无法访问salary的值。为了遵循数据的隐蔽性原则，我们不能将它定义为public类型。不过，我们可以借助super关键字来达到目的。\n以下是修改过的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Main { public static void main(String[] args) { Manager manager = new Manager(); manager.setBonus(8000); System.out.println(manager.getSalary()); } } class Employee{ private int salary = 6000; public void setSalary(int salary){ this.salary = salary; } //获得salary的值 public int getSalary(){ return salary; } } class Manager extends Employee{ private int bonus = 0; public void setBonus(int bonus){ this.bonus = bonus; } public int getBonus(){ return bonus; } @Override public int getSalary(){ return bonus + super.getSalary();\t//改为 super.getSalary } } 在这段代码中，增加了getSalary()函数，这个函数返回salary的值。由于可以使用关键字super访问超类的成员函数和变量，super.getSalary()就获得了Employee类的salary变量。\n调用父类的构造方法 举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Main { public static void main(String[] args) { Manager manager = new Manager(8000); manager.setBonus(800); System.out.println(manager.getSalary()); } } class Employee{ public Employee(int salary){ this.salary = salary; } private int salary = 6000; public void setSalary(int salary){ this.salary = salary; } public int getSalary(){ return salary; } } class Manager extends Employee{ private int bonus = 0; public Manager(int salary) { super(salary);\t//调用超类的构造器 } public void setBonus(int bonus){ this.bonus = bonus; } public int getBonus(){ return bonus; } @Override public int getSalary(){ return bonus + super.getSalary(); } } manger无法访问超类的私有成员，但是可以通过超类的构造器来访问它们。\n注意：超类的构造器必须是子类的构造器里面的第一个语句！\n解决成员变量名或方法名冲突 举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 class Parent { int x = 10; } class Child extends Parent { int x = 20; void display() { System.out.println(\u0026#34;Child x = \u0026#34; + x); // 访问 Child 类的 x System.out.println(\u0026#34;Parent x = \u0026#34; + super.x); // 使用 super 访问 Parent 类的 x } } 当子类中的成员变量名或方法名与超类中的成员变量名或方法名相同时，子类中的方法或变量会隐藏超类中的方法或变量。此时，如果你想在子类中访问被隐藏的超类成员，就需要使用super 关键字。\n","date":"2024-09-09T00:00:00Z","image":"https://programcx.github.io/p/java%E4%B8%ADsuper%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3/java_hu2582121eb752963b1ceb7fad85fc990d_36519_120x120_fill_q75_box_smart1.jpg","permalink":"https://programcx.github.io/p/java%E4%B8%ADsuper%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3/","title":"Java中super关键字的理解"},{"content":"C++代码规范总结（部分） 下面内容总结（有的是直接复制概述，因为原文讲的比较严谨）于https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/\n头文件 #include的路径和顺序（每个类型之间要有空行） 配套的头文件 C语言系统文件 C++标准库头文件 其他库的头文件 本项目的头文件 要有#define防护符 避免向前声明 10行以下用内联函数 作用域 禁止使用using namespace ...; 大型项目要使用命名空间，以注释结尾 尽量将非成员函数放入命名空间，不要使用全局函数 最好初始化时声明 要在循环外声明类 尽量不要使用全局的静态变量、类，除非它们可以平凡地析构 构造函数中不得使用虚函数， 尽量不要使用隐式转换类型，单参数函数使用explicit关键字 int、double等类型建议使用传值、std::string等类型建议使用传引用，尽量不要传指针 基类最好是抽象类，且构造函数和析构函数必须声明为protected，最好不要继承具体类 只能用 struct 定义那些用于储存数据的被动对象. 其他情况应该使用 class 组合优于继承，使用public继承 谨慎使用重载运算符，除非与直觉相同；禁止使用自定义字面量 必须将所有数据成员声明为private 声明次序 public protected private 以下是每一个不同作用域的声明次序： 类型和类型别名 （仅适用于结构体），非静态数据成员 静态常量 工厂函数 构造函数和赋值运算符 析构函数 所有其他函数，包括静态和非静态函数，以及友元函数 其它数据成员，包括静态和非静态的 函数 行数超过40行在不影响程序逻辑的情况下要进行分割 只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法 尽量不使用缺省函数参数，少数极端情况除外。尽可能改用函数重载 允许合理的使用友元类及友元函数 其它C++特性 尽量不使用 C++ 异常. 不要使用强制转换 除了写日志，尽量不要使用流 对于迭代器和其他模板对象使用前缀形式 (++i) 的自增, 自减运算符 任何可能的情况下都要使用 const 使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之 指针使用nullptr，字符使用'\\0'，而不是0字面量 尽可能用 sizeof(varname) 代替 sizeof(type) 使用auto绕过繁琐的类型名称，但要可读性好 可以用列表初始化 使用预处理宏时要非常谨慎，下面是要使用宏时需要遵守的规则： 不要在头文件中使用宏 在马上要使用时才进行 #define, 使用后要立即#undef 不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称 不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为 不要用 ## 处理函数，类和变量的名字 适当使用lambda表达式，当lambda将转移当前作用域时，首选显式捕捉 不要使用复杂的模板编程 命名约定 函数命名, 变量命名, 文件命名要有描述性; 少用缩写 文件名全部要小写，可以包含“-”或“_” 类型名称首字母要大写，不能有下划线 变量命名要全部小写，单词之间使用下划线 常规函数使用大小写混合 命名空间要小写，不可以出现缩写 枚举的命名应当和常量或宏一致 通常不应该使用宏. 如果不得不用, 其命名像枚举命名一样全部大写, 使用下划线 注释 在每一个文件开头加入版权公告，包含法律、版权、作者信息。应当对文件的内容做一个大致的说明, 同时说明各概念之间的联系。 每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显 函数声明处的注释描述函数功能; 定义处的注释描述函数实现 每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途,如果变量可以接受 NULL 或 -1 等警戒值, 须加以说明 所有全局变量也要注释说明含义及用途, 以及作为全局变量的原因 对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释 巧妙或复杂的代码段前要加注释 比较隐晦的地方要在行尾加入注释 永远不要 用自然语言翻译代码作为注释 对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 TODO 注释，并加上自己身份标识 格式 每一行代码字符数不超过 80 尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码 只使用空格, 每次缩进 2 个空格 返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与 函数调用 一致 如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用 else 子句时使用 单行语句不需要使用大括号, 如果你喜欢用也没问题; 复杂的条件或循环语句用大括号可读性会更好. 也有一些项目要求 if 必须总是使用大括号 如果有不满足 case 条件的枚举值, switch 应该总是包含一个 default 匹配，如果 default 应该永远执行不到, 简单的加条 assert 在单语句循环里, 括号可用可不用 空循环体应使用 {} 或 continue, 而不是一个简单的分号 句点或箭头前后不要有空格. 指针/地址操作符 (*, \u0026amp;) 之后不能有空格 如果一个布尔表达式超过 标准行宽, 断行方式要统一一下 预处理指令不要缩进, 从行首开始 构造函数初始化列表放在同一行或按四格缩进并排多行 命名空间内容不缩进 两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行, 函数体中也不要随意添加空行 规则特例 不要使用 #pragma once ","date":"2024-09-05T00:00:00Z","image":"https://programcx.github.io/p/c-/cpp_hu4f8d777476dd4c631cf6bb374e06af91_91138_120x120_fill_q75_box_smart1.jpg","permalink":"https://programcx.github.io/p/c-/","title":"C++ 代码规范总结"},{"content":"该文章用来记录java学习过程中看似应该不会发生的异常\n我们有一个 Main.java 和 cn/pinsoftstd/Study.java，源代码如下：\nMain.java:\n1 2 3 4 5 6 7 8 9 10 11 12 import cn.pinsoftstd.study.Study; public class Main { public static void main(String[] args) { Study study=new Study(); study.printHelloWorld(); study.addProgramming(\u0026#34;XiaoMing\u0026#34;); study.addProgramming(\u0026#34;XiaoHong\u0026#34;); study.addProgramming(\u0026#34;LiJun\u0026#34;); study.removeProgramming(\u0026#34;LiJun\u0026#34;);\t//发生异常 study.printProgramingNames(); } } cn/pinsoftstd/Study.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 package cn.pinsoftstd.study; import java.util.ArrayList; import java.util.Iterator; /** * The class study provides an interface for developers to add and remove * the ones who are studying programming or not. * @author Program * @version 1.0 */ public class Study { public Study(){ } /** This prints \u0026#34;Hello World\u0026#34;,which is the person who must print once * study a programming language. * @author Program */ public void printHelloWorld(){ System.out.println(\u0026#34;Hello World\u0026#34;); } /** * This method adds a person to the Study Programming category. */ public Programming addProgramming(String name){ Programming pr=new Programming(name); programmings.add(pr); return pr; } /** * This method removes a person from the Study Programming category. */ public boolean removeProgramming(String name) { boolean removed = false; for (Programming pr : programmings) { if (pr.name.equals(name)) { programmings.remove(pr);\t//发生异常 removed = true; } } return removed; } /** * This method prints the names of people who are studying programming. */ public void printProgramingNames(){ for(Programming pr:programmings){ System.out.println(pr.name); } } private ArrayList\u0026lt;Programming\u0026gt; programmings=new ArrayList\u0026lt;\u0026gt;(); public class Programming{ private String name; public Programming(String name){ this.name=name; } public String name(){ return this.name; } public void printStudyingProgramming(){ System.out.println(\u0026#34;Study Programming:\u0026#34;+name); } } } 自己写的时候感觉没有问题，结果运行的时候抛出了 java.ConcurrentModificationException 异常。异常代码为Main.java中的 study.printProgramingNames();，Study.java中的programmings.remove(pr);。 其实，是因为在 Java 中增强型for循环使用了迭代器(iterator)遍历，如果在遍历的时候使用了 study.printProgramingNames();，迭代器会检测到数组列表的变化，从而抛出java.util.ConcurrentModificationException 异常。\n解决方法 方法一：使用迭代器遍历programmings数组列表，不使用增强型for循环遍历。下面是修改后的代码： 1 2 3 4 5 6 7 8 9 10 11 12 public boolean removeProgramming(String name) { boolean removed=false; Iterator\u0026lt;Programming\u0026gt;it=programmings.iterator(); while (it.hasNext()){\t//使用迭代器遍历 Programming pr=it.next(); if(pr.name.equals(name)){ it.remove(); removed=true; } } return removed; } 方法二：通过遍历索引(index)来遍历数组列表programmings。下面是修改后的代码:\n1 2 3 4 5 6 7 8 9 10 public boolean removeProgramming(String name) { boolean removed = false; for(int i=0;i\u0026lt;programmings.size();i++){ if(programmings.get(i).name.equals(name)){ programmings.remove(i); removed = true; } } return removed; } ","date":"2024-09-05T00:00:00Z","image":"https://programcx.github.io/p/java/java_hu2582121eb752963b1ceb7fad85fc990d_36519_120x120_fill_q75_box_smart1.jpg","permalink":"https://programcx.github.io/p/java/","title":"Java 一种 java.util.ConcurrentModificationException 异常原因"},{"content":"这个博客用来回忆这道题目，本人算法新手\n题目： 在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：\n值 0 代表空单元格； 值 1 代表新鲜橘子； 值 2 代表腐烂的橘子。 每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。\n返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。\n示例 1： 输入：grid = [[2,1,1],[1,1,0],[0,1,1]] 输出：4\n示例 2： 输入：grid = [[2,1,1],[0,1,1],[1,0,1]] 输出：-1 解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个方向上。\n示例 3： 输入：grid = [[0,2]] 输出：0 解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。\n提示：\nm == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 10 grid[i][j] 仅为 0、1 或 2 解题思路 先遍历所有的网格，统计新鲜橘子的个数，并把腐烂的橘子添加到队列。 使用广度优先搜索（BFS），不断感染四周的橘子，将已经感染过其他橘子的烂橘子从队列中弹出（便于统计还有哪些橘子没有感染其他好橘子）。每感染一个橘子，将新鲜橘子个数减去一。每感染一轮，时间加一。 最后检测新鲜的橘子个数是否为零，如果为零，则返回总共花去的分钟数；如果新鲜的橘子个数不为零，说明还有橘子永远不会被感染，根据题目要求，返回-1。 解题代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public: int orangesRotting(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int m = grid.size();\t//记录每一行的橘子个数 if (m == 0) return -1; //如果没有橘子，直接返回-1 int n = grid[0].size(); //记录每一列橘子个数 if (n == 0) return -1; queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; int fresh = 0; //遍历所有网格 for (int i = 0; i \u0026lt; m; ++i) { for (int j = 0; j \u0026lt; n; ++j) { if (grid[i][j] == 1) {\t//如果为新鲜橘子 fresh++;\t//新鲜橘子个数就加一 } if (grid[i][j] == 2) { //如果橘子不是新鲜的 q.emplace(i, j);\t//就把烂橘子放入队列 } } } //开始广度优先搜索（BFS） int minutes = 0; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; dirs = { {1,0},{-1,0},{0,1},{0,-1} }; //定义四个方向 while (!q.empty() \u0026amp;\u0026amp; fresh \u0026gt; 0) {\t//如果队列q不为空且有新鲜橘子 int size = q.size();\t//记录才开始或几轮下来还有多少未感染其他橘子的烂橘子 for (int k = 0; k \u0026lt; size; ++k) {\t//对这些橘子进行遍历 auto [i, j] = q.front(); //获取队列中第一个未感染其它橘子的烂橘子 q.pop();\t//将该橘子弹出 for (const auto\u0026amp; [x, y] : dirs) {\t//遍历四个方向 int dx = i + x, dy = j + y;\t//计算烂橘子四周的坐标值 if (dx \u0026gt;= 0 \u0026amp;\u0026amp; dx \u0026lt; m \u0026amp;\u0026amp; dy \u0026gt;= 0 \u0026amp;\u0026amp; dy \u0026lt; n \u0026amp;\u0026amp; grid[dx][dy] == 1) {\t//如果在矩阵范围内且该橘子是好橘子（避免重复感染和越界问题） grid[dx][dy] = 2;\t//就感染这个橘子 q.emplace(dx, dy); //将这个橘子添加到未感染其它橘子的烂橘子的队列 fresh--;\t//好橘子数量就减一 } } } ++minutes; //计算时间 } return fresh == 0 ? minutes : -1; } }; 提交结果 ","date":"2024-09-05T00:00:00Z","image":"https://programcx.github.io/p/leetcode-%E7%AC%AC994%E9%A2%98-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/question_hu80ece0439f120d211a32693abd2dfdea_42586_120x120_fill_box_smart1_3.png","permalink":"https://programcx.github.io/p/leetcode-%E7%AC%AC994%E9%A2%98-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/","title":"LeetCode 第994题 腐烂的橘子"},{"content":"记录学习\n填涂颜色 题目描述 由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：\n如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ 在闭合圈内。闭合圈不一定是环形的，可以是任意形状，但保证闭合圈内的 $0$ 是连通的（两两之间可以相互到达）。\n1 2 3 4 5 6 0 0 0 0 0 0 0 0 0 1 1 1 0 1 1 0 0 1 1 1 0 0 0 1 1 0 0 1 0 1 1 1 1 1 1 1 1 2 3 4 5 6 0 0 0 0 0 0 0 0 0 1 1 1 0 1 1 2 2 1 1 1 2 2 2 1 1 2 2 1 2 1 1 1 1 1 1 1 输入格式 每组测试数据第一行一个整数 $n(1 \\le n \\le 30)$。\n接下来 $n$ 行，由 $0$ 和 $1$ 组成的 $n \\times n$ 的方阵。\n方阵内只有一个闭合圈，圈内至少有一个 $0$。\n输出格式 已经填好数字 $2$ 的完整方阵。\n样例 #1 样例输入 #1 1 2 3 4 5 6 7 6 0 0 0 0 0 0 0 0 1 1 1 1 0 1 1 0 0 1 1 1 0 0 0 1 1 0 0 0 0 1 1 1 1 1 1 1 样例输出 #1 1 2 3 4 5 6 0 0 0 0 0 0 0 0 1 1 1 1 0 1 1 2 2 1 1 1 2 2 2 1 1 2 2 2 2 1 1 1 1 1 1 1 提示 对于 $100%$ 的数据，$1 \\le n \\le 30$。\n思路 1.输入矩阵 2.进行BFS搜索，标记搜索过的 3.输出，如果值为零且未被标记，则一定是被包围的，就输出2\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; struct point { int x = 0; int y = 0; }; queue\u0026lt;point\u0026gt; q; int dx[4] = { -1,1,0,0 }, dy[4] = { 0,0,-1,1 }; int land[35][35] = {0}, mark[35][35] = {0}, n, tmp; int main() { cin \u0026gt;\u0026gt; n; //输入 for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { cin \u0026gt;\u0026gt; tmp; if (tmp == 1) { land[i][j] = tmp; } } } //把起始点标记为经过 mark[0][0] = 1; q.push(point{0,0}); //开始bfs搜索 while (!q.empty())\t//一直到搜索完成 { point p = q.front();\t//取出搜索队列的第一个元素 q.pop();\t//弹出第一个元素 //前后左右 for (int i = 0; i \u0026lt; 4; i++) { int x = dx[i] + p.x; int y = dy[i] + p.y; //如果越界，就跳出此次循环 if (x \u0026lt; 0 || x \u0026gt; n || y \u0026lt; 0 || y \u0026gt; n ) continue; //如果未被搜索且数值为零 if (land[x][y] == 0 \u0026amp;\u0026amp; mark[x][y] == 0) { mark[x][y] = 1;\t//标记为已经搜索 q.push(point{ x,y });\t//加入搜索队列 } } } cout \u0026lt;\u0026lt; endl; //遍历矩阵 for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { //如果没被搜索过 if (land[i][j] == 0 \u0026amp;\u0026amp; mark[i][j] == 0) { cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t//说明被包围，则输出2 } else if (land[i][j] == 1) { cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t//1就是边界 } else { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t//否则就是搜过的0 } } cout \u0026lt;\u0026lt; endl; } return 0; } ","date":"2024-09-05T00:00:00Z","permalink":"https://programcx.github.io/p/%E6%B4%9B%E8%B0%B7-p1162-%E5%A1%AB%E6%B6%82%E9%A2%9C%E8%89%B2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/","title":"洛谷 P1162 填涂颜色 广度优先搜索"}]