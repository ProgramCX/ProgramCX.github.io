[{"content":"C++代码规范总结（部分） 下面内容总结（有的是直接复制概述，因为原文讲的比较严谨）于https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/\n头文件 #include的路径和顺序（每个类型之间要有空行） 配套的头文件 C语言系统文件 C++标准库头文件 其他库的头文件 本项目的头文件 要有#define防护符 避免向前声明 10行以下用内联函数 作用域 禁止使用using namespace ...; 大型项目要使用命名空间，以注释结尾 尽量将非成员函数放入命名空间，不要使用全局函数 最好初始化时声明 要在循环外声明类 尽量不要使用全局的静态变量、类，除非它们可以平凡地析构 构造函数中不得使用虚函数， 尽量不要使用隐式转换类型，单参数函数使用explicit关键字 int、double等类型建议使用传值、std::string等类型建议使用传引用，尽量不要传指针 基类最好是抽象类，且构造函数和析构函数必须声明为protected，最好不要继承具体类 只能用 struct 定义那些用于储存数据的被动对象. 其他情况应该使用 class 组合优于继承，使用public继承 谨慎使用重载运算符，除非与直觉相同；禁止使用自定义字面量 必须将所有数据成员声明为private 声明次序 public protected private 以下是每一个不同作用域的声明次序： 类型和类型别名 （仅适用于结构体），非静态数据成员 静态常量 工厂函数 构造函数和赋值运算符 析构函数 所有其他函数，包括静态和非静态函数，以及友元函数 其它数据成员，包括静态和非静态的 函数 行数超过40行在不影响程序逻辑的情况下要进行分割 只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法 尽量不使用缺省函数参数，少数极端情况除外。尽可能改用函数重载 允许合理的使用友元类及友元函数 其它C++特性 尽量不使用 C++ 异常. 不要使用强制转换 除了写日志，尽量不要使用流 对于迭代器和其他模板对象使用前缀形式 (++i) 的自增, 自减运算符 任何可能的情况下都要使用 const 使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之 指针使用nullptr，字符使用'\\0'，而不是0字面量 尽可能用 sizeof(varname) 代替 sizeof(type) 使用auto绕过繁琐的类型名称，但要可读性好 可以用列表初始化 使用预处理宏时要非常谨慎，下面是要使用宏时需要遵守的规则： 不要在头文件中使用宏 在马上要使用时才进行 #define, 使用后要立即#undef 不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称 不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为 不要用 ## 处理函数，类和变量的名字 适当使用lambda表达式，当lambda将转移当前作用域时，首选显式捕捉 不要使用复杂的模板编程 命名约定 函数命名, 变量命名, 文件命名要有描述性; 少用缩写 文件名全部要小写，可以包含“-”或“_” 类型名称首字母要大写，不能有下划线 变量命名要全部小写，单词之间使用下划线 常规函数使用大小写混合 命名空间要小写，不可以出现缩写 枚举的命名应当和常量或宏一致 通常不应该使用宏. 如果不得不用, 其命名像枚举命名一样全部大写, 使用下划线 注释 在每一个文件开头加入版权公告，包含法律、版权、作者信息。应当对文件的内容做一个大致的说明, 同时说明各概念之间的联系。 每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显 函数声明处的注释描述函数功能; 定义处的注释描述函数实现 每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途,如果变量可以接受 NULL 或 -1 等警戒值, 须加以说明 所有全局变量也要注释说明含义及用途, 以及作为全局变量的原因 对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释 巧妙或复杂的代码段前要加注释 比较隐晦的地方要在行尾加入注释 永远不要 用自然语言翻译代码作为注释 对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 TODO 注释，并加上自己身份标识 格式 每一行代码字符数不超过 80 尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码 只使用空格, 每次缩进 2 个空格 返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与 函数调用 一致 如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用 else 子句时使用 单行语句不需要使用大括号, 如果你喜欢用也没问题; 复杂的条件或循环语句用大括号可读性会更好. 也有一些项目要求 if 必须总是使用大括号 如果有不满足 case 条件的枚举值, switch 应该总是包含一个 default 匹配，如果 default 应该永远执行不到, 简单的加条 assert 在单语句循环里, 括号可用可不用 空循环体应使用 {} 或 continue, 而不是一个简单的分号 句点或箭头前后不要有空格. 指针/地址操作符 (*, \u0026amp;) 之后不能有空格 如果一个布尔表达式超过 标准行宽, 断行方式要统一一下 预处理指令不要缩进, 从行首开始 构造函数初始化列表放在同一行或按四格缩进并排多行 命名空间内容不缩进 两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行, 函数体中也不要随意添加空行 规则特例 不要使用 #pragma once ","date":"2024-09-05T00:00:00Z","image":"https://programcx.github.io/p/c-/cpp_hu17877837520322365017.jpg","permalink":"https://programcx.github.io/p/c-/","title":"C++ 代码规范总结"},{"content":"该文章用来记录java学习过程中看似应该不会发生的异常\n我们有一个 Main.java 和 cn/pinsoftstd/Study.java，源代码如下：\nMain.java:\n1 2 3 4 5 6 7 8 9 10 11 12 import cn.pinsoftstd.study.Study; public class Main { public static void main(String[] args) { Study study=new Study(); study.printHelloWorld(); study.addProgramming(\u0026#34;XiaoMing\u0026#34;); study.addProgramming(\u0026#34;XiaoHong\u0026#34;); study.addProgramming(\u0026#34;LiJun\u0026#34;); study.removeProgramming(\u0026#34;LiJun\u0026#34;);\t//发生异常 study.printProgramingNames(); } } cn/pinsoftstd/Study.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 package cn.pinsoftstd.study; import java.util.ArrayList; import java.util.Iterator; /** * The class study provides an interface for developers to add and remove * the ones who are studying programming or not. * @author Program * @version 1.0 */ public class Study { public Study(){ } /** This prints \u0026#34;Hello World\u0026#34;,which is the person who must print once * study a programming language. * @author Program */ public void printHelloWorld(){ System.out.println(\u0026#34;Hello World\u0026#34;); } /** * This method adds a person to the Study Programming category. */ public Programming addProgramming(String name){ Programming pr=new Programming(name); programmings.add(pr); return pr; } /** * This method removes a person from the Study Programming category. */ public boolean removeProgramming(String name) { boolean removed = false; for (Programming pr : programmings) { if (pr.name.equals(name)) { programmings.remove(pr);\t//发生异常 removed = true; } } return removed; } /** * This method prints the names of people who are studying programming. */ public void printProgramingNames(){ for(Programming pr:programmings){ System.out.println(pr.name); } } private ArrayList\u0026lt;Programming\u0026gt; programmings=new ArrayList\u0026lt;\u0026gt;(); public class Programming{ private String name; public Programming(String name){ this.name=name; } public String name(){ return this.name; } public void printStudyingProgramming(){ System.out.println(\u0026#34;Study Programming:\u0026#34;+name); } } } 自己写的时候感觉没有问题，结果运行的时候抛出了 java.ConcurrentModificationException 异常。异常代码为Main.java中的 study.printProgramingNames();，Study.java中的programmings.remove(pr);。 其实，是因为在 Java 中增强型for循环使用了迭代器(iterator)遍历，如果在遍历的时候使用了 study.printProgramingNames();，迭代器会检测到数组列表的变化，从而抛出java.util.ConcurrentModificationException 异常。\n解决方法 方法一：使用迭代器遍历programmings数组列表，不使用增强型for循环遍历。下面是修改后的代码： 1 2 3 4 5 6 7 8 9 10 11 12 public boolean removeProgramming(String name) { boolean removed=false; Iterator\u0026lt;Programming\u0026gt;it=programmings.iterator(); while (it.hasNext()){\t//使用迭代器遍历 Programming pr=it.next(); if(pr.name.equals(name)){ it.remove(); removed=true; } } return removed; } 方法二：通过遍历索引(index)来遍历数组列表programmings。下面是修改后的代码:\n1 2 3 4 5 6 7 8 9 10 public boolean removeProgramming(String name) { boolean removed = false; for(int i=0;i\u0026lt;programmings.size();i++){ if(programmings.get(i).name.equals(name)){ programmings.remove(i); removed = true; } } return removed; } ","date":"2024-09-05T00:00:00Z","image":"https://programcx.github.io/p/java/java_hu14469118171915315630.jpg","permalink":"https://programcx.github.io/p/java/","title":"Java 一种 java.util.ConcurrentModificationException 异常原因"},{"content":"这个博客用来回忆这道题目，本人算法新手\n题目： 在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：\n值 0 代表空单元格； 值 1 代表新鲜橘子； 值 2 代表腐烂的橘子。 每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。\n返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。\n示例 1： 输入：grid = [[2,1,1],[1,1,0],[0,1,1]] 输出：4\n示例 2： 输入：grid = [[2,1,1],[0,1,1],[1,0,1]] 输出：-1 解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个方向上。\n示例 3： 输入：grid = [[0,2]] 输出：0 解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。\n提示：\nm == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 10 grid[i][j] 仅为 0、1 或 2 解题思路 先遍历所有的网格，统计新鲜橘子的个数，并把腐烂的橘子添加到队列。 使用广度优先搜索（BFS），不断感染四周的橘子，将已经感染过其他橘子的烂橘子从队列中弹出（便于统计还有哪些橘子没有感染其他好橘子）。每感染一个橘子，将新鲜橘子个数减去一。每感染一轮，时间加一。 最后检测新鲜的橘子个数是否为零，如果为零，则返回总共花去的分钟数；如果新鲜的橘子个数不为零，说明还有橘子永远不会被感染，根据题目要求，返回-1。 解题代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public: int orangesRotting(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int m = grid.size();\t//记录每一行的橘子个数 if (m == 0) return -1; //如果没有橘子，直接返回-1 int n = grid[0].size(); //记录每一列橘子个数 if (n == 0) return -1; queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; int fresh = 0; //遍历所有网格 for (int i = 0; i \u0026lt; m; ++i) { for (int j = 0; j \u0026lt; n; ++j) { if (grid[i][j] == 1) {\t//如果为新鲜橘子 fresh++;\t//新鲜橘子个数就加一 } if (grid[i][j] == 2) { //如果橘子不是新鲜的 q.emplace(i, j);\t//就把烂橘子放入队列 } } } //开始广度优先搜索（BFS） int minutes = 0; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; dirs = { {1,0},{-1,0},{0,1},{0,-1} }; //定义四个方向 while (!q.empty() \u0026amp;\u0026amp; fresh \u0026gt; 0) {\t//如果队列q不为空且有新鲜橘子 int size = q.size();\t//记录才开始或几轮下来还有多少未感染其他橘子的烂橘子 for (int k = 0; k \u0026lt; size; ++k) {\t//对这些橘子进行遍历 auto [i, j] = q.front(); //获取队列中第一个未感染其它橘子的烂橘子 q.pop();\t//将该橘子弹出 for (const auto\u0026amp; [x, y] : dirs) {\t//遍历四个方向 int dx = i + x, dy = j + y;\t//计算烂橘子四周的坐标值 if (dx \u0026gt;= 0 \u0026amp;\u0026amp; dx \u0026lt; m \u0026amp;\u0026amp; dy \u0026gt;= 0 \u0026amp;\u0026amp; dy \u0026lt; n \u0026amp;\u0026amp; grid[dx][dy] == 1) {\t//如果在矩阵范围内且该橘子是好橘子（避免重复感染和越界问题） grid[dx][dy] = 2;\t//就感染这个橘子 q.emplace(dx, dy); //将这个橘子添加到未感染其它橘子的烂橘子的队列 fresh--;\t//好橘子数量就减一 } } } ++minutes; //计算时间 } return fresh == 0 ? minutes : -1; } }; 提交结果 ","date":"2024-09-05T00:00:00Z","image":"https://programcx.github.io/p/leetcode-%E7%AC%AC994%E9%A2%98-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/question_hu920221992150309940.png","permalink":"https://programcx.github.io/p/leetcode-%E7%AC%AC994%E9%A2%98-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/","title":"LeetCode 第994题 腐烂的橘子"},{"content":"记录学习\n填涂颜色 题目描述 由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：\n如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ 在闭合圈内。闭合圈不一定是环形的，可以是任意形状，但保证闭合圈内的 $0$ 是连通的（两两之间可以相互到达）。\n1 2 3 4 5 6 0 0 0 0 0 0 0 0 0 1 1 1 0 1 1 0 0 1 1 1 0 0 0 1 1 0 0 1 0 1 1 1 1 1 1 1 1 2 3 4 5 6 0 0 0 0 0 0 0 0 0 1 1 1 0 1 1 2 2 1 1 1 2 2 2 1 1 2 2 1 2 1 1 1 1 1 1 1 输入格式 每组测试数据第一行一个整数 $n(1 \\le n \\le 30)$。\n接下来 $n$ 行，由 $0$ 和 $1$ 组成的 $n \\times n$ 的方阵。\n方阵内只有一个闭合圈，圈内至少有一个 $0$。\n输出格式 已经填好数字 $2$ 的完整方阵。\n样例 #1 样例输入 #1 1 2 3 4 5 6 7 6 0 0 0 0 0 0 0 0 1 1 1 1 0 1 1 0 0 1 1 1 0 0 0 1 1 0 0 0 0 1 1 1 1 1 1 1 样例输出 #1 1 2 3 4 5 6 0 0 0 0 0 0 0 0 1 1 1 1 0 1 1 2 2 1 1 1 2 2 2 1 1 2 2 2 2 1 1 1 1 1 1 1 提示 对于 $100%$ 的数据，$1 \\le n \\le 30$。\n思路 1.输入矩阵 2.进行BFS搜索，标记搜索过的 3.输出，如果值为零且未被标记，则一定是被包围的，就输出2\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; struct point { int x = 0; int y = 0; }; queue\u0026lt;point\u0026gt; q; int dx[4] = { -1,1,0,0 }, dy[4] = { 0,0,-1,1 }; int land[35][35] = {0}, mark[35][35] = {0}, n, tmp; int main() { cin \u0026gt;\u0026gt; n; //输入 for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { cin \u0026gt;\u0026gt; tmp; if (tmp == 1) { land[i][j] = tmp; } } } //把起始点标记为经过 mark[0][0] = 1; q.push(point{0,0}); //开始bfs搜索 while (!q.empty())\t//一直到搜索完成 { point p = q.front();\t//取出搜索队列的第一个元素 q.pop();\t//弹出第一个元素 //前后左右 for (int i = 0; i \u0026lt; 4; i++) { int x = dx[i] + p.x; int y = dy[i] + p.y; //如果越界，就跳出此次循环 if (x \u0026lt; 0 || x \u0026gt; n || y \u0026lt; 0 || y \u0026gt; n ) continue; //如果未被搜索且数值为零 if (land[x][y] == 0 \u0026amp;\u0026amp; mark[x][y] == 0) { mark[x][y] = 1;\t//标记为已经搜索 q.push(point{ x,y });\t//加入搜索队列 } } } cout \u0026lt;\u0026lt; endl; //遍历矩阵 for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { //如果没被搜索过 if (land[i][j] == 0 \u0026amp;\u0026amp; mark[i][j] == 0) { cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t//说明被包围，则输出2 } else if (land[i][j] == 1) { cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t//1就是边界 } else { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t//否则就是搜过的0 } } cout \u0026lt;\u0026lt; endl; } return 0; } ","date":"2024-09-05T00:00:00Z","permalink":"https://programcx.github.io/p/%E6%B4%9B%E8%B0%B7-p1162-%E5%A1%AB%E6%B6%82%E9%A2%9C%E8%89%B2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/","title":"洛谷 P1162 填涂颜色 广度优先搜索"}]